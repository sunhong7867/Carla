#!/usr/bin/env python
import math
import carla
import csv
from pathlib import Path

from srunner.scenariomanager.actorcontrols.basic_control import BasicControl
from srunner.scenariomanager.carla_data_provider import CarlaDataProvider

from decision import ego_vehicle_estimation as EGO
from decision.shared_types import TimeData, GPSData, IMUData, EgoVehicleKFState


class AutonomousDrivingSystem(BasicControl):
    def __init__(self, actor, args=None):
        super().__init__(actor)
        print("=========== ADAS Python System Activated ===========")

        self._actor = actor
        self.spectator = CarlaDataProvider.get_world().get_spectator()
        self.world = CarlaDataProvider.get_world()
        self.map = self.world.get_map()
        self.ego_id = actor.id

        self.kf_state = EGO.init_ego_vehicle_kf_state()
        self.gps_data = GPSData(0.0, 0.0, 0.0)
        self.imu_data = IMUData(0.0, 0.0, 0.0)
        self.time_data = TimeData(0.0)

        self.prev_timestamp = 0.0
        self.sim_start_time = None
        self.gps_sensor_time = 0.0

        self.last_imu_time = 0.0
        self.last_gps_time = 0.0
        self.imu_intervals = []
        self.gps_intervals = []

        self.vel_record = []
        self.vel_buffer = []
        self.acc_buffer = []

        self.control = carla.VehicleControl()

        self._set_imu_sensor()
        self._set_gps_sensor()

        self.log_data = []
        self.last_log_time = 0.0

    def _init_control(self):
        self.control = carla.VehicleControl()
        self.control.steer = 0.0
        self.control.throttle = 0.0
        self.control.brake = 0.0

    def _set_imu_sensor(self):
        blueprint = self.world.get_blueprint_library().find('sensor.other.imu')
        imu_transform = carla.Transform(carla.Location(), carla.Rotation())
        self.imu_sensor = self.world.spawn_actor(blueprint, imu_transform, attach_to=self._actor)
        self.imu_sensor.listen(lambda imu: self._on_imu_update(imu))

    def _set_gps_sensor(self):
        bp = self.world.get_blueprint_library().find('sensor.other.gnss')
        bp.set_attribute('sensor_tick', '0.05')
        gps_transform = carla.Transform(carla.Location(), carla.Rotation())
        self.gps_sensor = self.world.spawn_actor(bp, gps_transform, attach_to=self._actor)
        self.gps_sensor.listen(lambda gps: self._on_gps_update(gps))

    def _on_imu_update(self, data):
        now = self.world.get_snapshot().timestamp.elapsed_seconds * 1000.0
        if self.last_imu_time > 0:
            interval = now - self.last_imu_time
            self.imu_intervals.append(interval)
        self.last_imu_time = now

        self.imu_data.accel_x = data.accelerometer.x
        self.imu_data.accel_y = data.accelerometer.y
        self.imu_data.yaw_rate = math.degrees(data.gyroscope.z)

    def _on_gps_update(self, data):
        now = self.world.get_snapshot().timestamp.elapsed_seconds * 1000.0
        if self.last_gps_time > 0:
            interval = now - self.last_gps_time
            self.gps_intervals.append(interval)
        self.last_gps_time = now

        self.gps_sensor_time = data.timestamp * 1000.0

    def _spectator_update(self):
        transform = self._actor.get_transform()
        transform.location.x -= 10
        transform.location.z += 5
        self.spectator.set_transform(transform)

    def run_step(self):
        timestamp = self.world.get_snapshot().timestamp.elapsed_seconds * 1000.0
        if self.sim_start_time is None:
            self.sim_start_time = timestamp

        elapsed_sec = (timestamp - self.sim_start_time) / 1000.0
        self.time_data.current_time = timestamp

        # === 차량 속도 기반 GPS 데이터 구성 ===
        vel = self._actor.get_velocity()
        gps_data = GPSData(
            velocity_x=vel.x,
            velocity_y=vel.y,
            timestamp=self.gps_sensor_time,
            last_received_time_ms=self.gps_sensor_time
        )


        # === 센서 유효성 판단 ===
        gps_dt = abs(timestamp - self.gps_sensor_time)
        gps_update_enabled = gps_dt <= 50.0

        # === Kalman 필터 상태 업데이트 ===
        ego = EGO.ego_vehicle_estimation(
            time_data=self.time_data,
            gps_data=gps_data,
            imu_data=self.imu_data,
            kf=self.kf_state
        )

        # === 가속/속도 조절 (단순 주행) ===
        gt_vel = self._actor.get_velocity()
        gt_speed = math.sqrt(gt_vel.x ** 2 + gt_vel.y ** 2 + gt_vel.z ** 2)

        if gt_speed < 15.0:
            self.control.throttle = 0.8
            self.control.brake = 0.0
        else:
            self.control.throttle = 0.6
            self.control.brake = 0.0

        self._actor.apply_control(self.control)
        self._spectator_update()

        # === Ego 차량 Transform 및 속도 ===
        ego_transform = self._actor.get_transform()
        carla_loc = ego_transform.location
        yaw_rad = math.radians(ego_transform.rotation.yaw)
        vel = self._actor.get_velocity()

        # === Ego 앞바퀴 중심 좌표 계산 (차량 기준 offset: +3.1m 전방) ===
        front_axle_offset = 3.1
        ego_pos_x = carla_loc.x + front_axle_offset * math.cos(yaw_rad)
        ego_pos_y = carla_loc.y + front_axle_offset * math.sin(yaw_rad)
        ego_pos_z = carla_loc.z

        # === Target 차량 (앞바퀴 기준 상대 위치 계산) ===
        objects = self.world.get_actors().filter("vehicle.*")
        target_obj = [o for o in objects if o.id != self.ego_id]
        if target_obj:
            target = target_obj[0]
            target_transform = target.get_transform()
            target_loc = target_transform.location
            target_yaw_rad = math.radians(target_transform.rotation.yaw)

            # Target 앞바퀴 중심 좌표
            target_front_x = target_loc.x + front_axle_offset * math.cos(target_yaw_rad)
            target_front_y = target_loc.y + front_axle_offset * math.sin(target_yaw_rad)
            target_front_z = target_loc.z

            # Ego 기준 상대 위치 계산 (앞바퀴 중심 ↔ 앞바퀴 중심)
            dx = target_front_x - ego_pos_x
            dy = target_front_y - ego_pos_y
            dz = target_front_z - ego_pos_z

            cos_yaw = math.cos(-yaw_rad)
            sin_yaw = math.sin(-yaw_rad)

            rel_x = dx * cos_yaw - dy * sin_yaw
            rel_y = dx * sin_yaw + dy * cos_yaw

            rel_dist = rel_x  # 방향성 유지
            abs_dist = math.sqrt(dx ** 2 + dy ** 2 + dz ** 2)
        else:
            target_front_x = target_front_y = target_front_z = 0.0
            rel_x = rel_y = rel_dist = abs_dist = 0.0

        offset_error = abs(ego_pos_x - (carla_loc.x + 3.1))
        self.log_data.append({
            "time": round((self.time_data.current_time - self.sim_start_time) / 1000.0, 2),

            # Step 1: Ego 속도 추정
            "ego_velocity_x": round(ego.velocity_x, 2),
            "ego_acceleration_x": round(ego.accel_x, 2),

            # Step 2: GPS 무효화 판단
            "gps_dt": round(abs(self.time_data.current_time - self.gps_sensor_time), 2),
            "gps_update_enabled": gps_update_enabled,
            "raw_gps_velocity_x": round(gps_data.velocity_x, 2),
            "raw_gps_velocity_y": round(gps_data.velocity_y, 2),

            # Step 2: IMU 무효화 판단
            "filtered_accel_x": round(self.imu_data.accel_x, 2),
            "filtered_yaw_rate": round(self.imu_data.yaw_rate, 2),
            "raw_imu_accel_x": round(self.imu_data.accel_x, 2),
            "raw_imu_accel_y": round(self.imu_data.accel_y, 2),
            "raw_imu_yaw_rate": round(self.imu_data.yaw_rate, 2),

            # Step 3, 4: Ground Truth 비교용
            "gt_velocity": round(math.sqrt(vel.x ** 2 + vel.y ** 2 + vel.z ** 2), 2),
            "gt_acceleration": round(self._actor.get_acceleration().x, 2)
        })

    def reset(self):
        if self.log_data:
            path = Path("C:/Users/MSI-Book/Desktop/log/EGO_S003.csv")
            with open(path, "w", newline="") as f:
                writer = csv.DictWriter(f, fieldnames=self.log_data[0].keys())
                writer.writeheader()
                writer.writerows(self.log_data)
            print(f"[INFO] Step 로그 저장 완료: {path.name}")

        if self._actor and self._actor.is_alive:
            self._actor = None
        if hasattr(self, 'imu_sensor') and self.imu_sensor.is_alive:
            self.imu_sensor.stop()
            self.imu_sensor.destroy()
        if hasattr(self, 'gps_sensor') and self.gps_sensor.is_alive:
            self.gps_sensor.stop()
            self.gps_sensor.destroy()
